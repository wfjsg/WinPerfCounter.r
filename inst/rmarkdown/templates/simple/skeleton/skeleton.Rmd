---
title: "SimpleSystemSummary"
author: "WataruFujishige"
date: "2017/12/31"
output: html_document
params:
  csvfile: "../../../../../tests/testthat/test2.csv"
---

```{r setup, include=FALSE}
library(WinPerfCounter)
library(ggplot2)
library(ggthemes)
library(cowplot)
library(formattable)
library(tibble)
library(knitr)
time.lap = list()
time.lap <- c(time.lap, list(first = proc.time()))
dataRaw <- WinPerfCounter.readcsv(params$csvfile)
knitr::opts_chunk$set(echo = FALSE, warning=FALSE, fig.width=12, fig.height=8)
time.lap <- c(time.lap, list(RawReadFromCSV = proc.time()))

# --------------------------
# CPUの論理コア数と搭載メモリ量、システム全体に書くメモリ量
sysenv.cpucore <- 8
sysenv.memory <- 8
sysenv.memory.chartlimit <- 100
# 時間で絞り込む。
viewLimit <- FALSE
viewStart <- as.POSIXct("2018/01/07 21:08:00 JST")
viewEnd   <- as.POSIXct("2018/01/07 21:10:00 JST")

# n秒にviewPlotLimit以上のプロットしないようにランダムで間引く。マイナスにすると制限をしない
viewPlotLimit <- 5
# チャートの設定を変える。CPUは1コアあたりの使用率(4コアだと400%になる)。メモリの単位が[GB]
processes <- list(
  explorer = list( 
       cpu.scale.auto = TRUE, cpu.min = 0, cpu.max = 100,
       memory.scale.auto = TRUE, memory.min = 0, memory.max = 0.25), 
  OneDrive = list( 
       cpu.scale.auto = TRUE, cpu.min = 0, cpu.max = 10,
       memory.scale.auto = TRUE, memory.min = 0, memory.max = 1)
)

# --------------------------
rawStart <- min(dataRaw$Timestamp)
rawEnd <- max(dataRaw$Timestamp) 
duration <- rawEnd - rawStart
if( viewLimit ){
  data <- dataRaw %>% dplyr::filter(Timestamp >= viewStart & Timestamp <= viewEnd)
  viewDuration = viewEnd - viewStart
  time.lap <- c(time.lap, list(TimestampLimit = proc.time()))
}else{
  data <- dataRaw
  viewStart <- rawStart
  viewEnd <- rawEnd
}
```

# Summary

```{r, asis=TRUE}
if( viewPlotLimit > 0 ){
  plotPerSeconds <- as.numeric(difftime(viewEnd, viewStart, units="secs")) / nrow(data)
  rate <- viewPlotLimit / plotPerSeconds
  if( rate > 1.0 ){
    after <- nrow(data) / rate
    pickNum <- sample(nrow(data), after)
    data <- data[pickNum,]
  }
}


{
  print(paste("StartDate : ", rawStart))
  print(paste("EndDate   : ", rawEnd))
  print(paste("DataPoints: ", nrow(dataRaw)))
  print(paste("Duration  : ", duration, units(duration)))

  if( viewLimit ){
    print(paste("viewLimit:", viewLimit))
    print(paste("ViewStart:", viewStart))
    print(paste("ViewEnd  :", viewEnd))
    print(paste("ViewDuration: ", viewDuration, units(viewDuration)))
  }else{
    print(paste("Start and End No-Limit"))
  }
  if( viewPlotLimit > 0 ){
    print(paste("DataPointDensity: ", plotPerSeconds, "point / sec"))
    print(paste("DesiredDensity:", viewPlotLimit, "point / sec"))
    if( rate > 1.0 ){
      print(paste("ViewPoints      : ", nrow(data), " With Limit"))
    }else{
      print(paste("ViewPoints      : ", nrow(data), " With NO-Limit"))
    }
    
  }
}
```

---

# Total

```{r}
cpu <- WinPerfCounter.Metric.CPU(data)
cpu_chart <- ggplot(cpu, aes(x=Timestamp, y=value)) + ggtitle("System CPU")
cpu_chart <- cpu_chart + geom_point(aes(colour = metric)) + ylim(0.0, 100.0)
cpu_chart <- cpu_chart + theme_gray()

memory <- WinPerfCounter.Metric.Memory(data)
memory_chart <- ggplot(memory, aes(x = Timestamp, y=valueInGB))  + ggtitle("System Memory")
memory_chart <- memory_chart + geom_hline(
  yintercept = sysenv.memory, linetype="dashed", colour="blue")
memory_chart <- memory_chart + annotate("text", label=paste(sysenv.memory, "GB Installed"), 
                                        x=viewStart, y=sysenv.memory, hjust = 0.0, vjust = -0.5)
memory_chart <- memory_chart + geom_point(aes(colour = metric)) + ylim(0, sysenv.memory.chartlimit)
memory_chart <- memory_chart + theme_gray()
```

## Summary(CPU)

```{r}
statistics <- WinPerfCounter.summary(cpu)
WinPerfCounter.formattable(statistics)
```

## Summary(Memory)[GB]
```{r}
statistics <- WinPerfCounter.summaryInGB(memory)
WinPerfCounter.formattable(statistics)
```

## Chart

```{r}
plot_grid(cpu_chart, memory_chart, ncol=1, align="v")
```
 
***

# Process(Explorer)

```{r}
processName <- "explorer"
p.cpu <- WinPerfCounter.Process.Metric.CPU(data, processName)
cpu_chart <- WinPerfCounter.Process.PlotCPU(p.cpu, processes, sysenv.cpu.core, processName)
p.memory <- WinPerfCounter.Process.Metric.Memory(data, processName)
memory_chart <- WinPerfCounter.Process.PlotMemory(p.memory, processes, sysenv.memory, processName)
```

## Summary(CPU)

```{r}
statistics <- WinPerfCounter.summary(p.cpu)
WinPerfCounter.formattable(statistics)
```

## Summary(Memory)[GB]

```{r}
statistics <- WinPerfCounter.summaryInGB(p.memory)
WinPerfCounter.formattable(statistics)
```

## Chart

```{r}
plot_grid(cpu_chart, memory_chart, ncol=1, align="v")
```

***

# Process(OneDrive)

```{r}
processName <- "OneDrive"
p.cpu <- WinPerfCounter.Process.Metric.CPU(data, processName)
cpu_chart <- WinPerfCounter.Process.PlotCPU(p.cpu, processes, sysenv.cpu.core, processName)
p.memory <- WinPerfCounter.Process.Metric.Memory(data, processName)
memory_chart <- WinPerfCounter.Process.PlotMemory(p.memory, processes, sysenv.memory, processName)
```

## Summary(CPU)

```{r}
statistics <- WinPerfCounter.summary(p.cpu)
WinPerfCounter.formattable(statistics)
```

## Summary(Memory)[GB]
```{r}
statistics <- WinPerfCounter.summaryInGB(p.memory)
WinPerfCounter.formattable(statistics)
```

## Chart

```{r}
plot_grid(cpu_chart, memory_chart, ncol=1, align="v")
```

***

# Means of Metrics

## CPU

### % Processor Time

いわゆるCPU使用率。

### % User Time & % Privileged Time

それぞれユーザーモードと特権モードで実行されたプロセッサ時間。Priviledged Time が User Timeの15%を超える場合、ディスクアレイがボトルネックである可能性がある。25%を超えるなら、可能性が高い。


## Memory

### Available Bytes

プロセスへ割り当て、もしくはシステムにすぐに利用できる物理メモリのサイズを示します。スタンバイ（キャッシュ済み）、空き、ゼロページの一覧にあるメモリの合計です。

### Committed Bytes

コミットされた仮想メモリのサイズをバイト数で表示します。コミット メモリは、領域がディスク ページング ファイルに予約されている物理メモリです。各物理ドライブにはページング ファイルが 1 つ以上あります。このカウンターは、平均値ではなく最新の監視値のみを表示します。

### Committed Limit

ページファイルを拡張せずにコミットできる仮想メモリの合計値です。


### Virtual Bytes

プロセスが保持する仮想メモリの総量を示します。メモリマップされたファイル(共有DLLも)や、ページアウトされたデータも含みます。

### Private Bytes

プロセスが要求した仮想メモリ量ですが、メモリマップされたファイルを *含みません* 。 物理メモリに張り付いているメモリ量ではなく、ページアウトされたメモリを含みます。

### Working Set

現在のプロセスが参照する *物理メモリ* の総量です。private bytesと違い、メモリマップされたファイル等各種のリソースを含みます。タスクマネージャの *Memory Usage* で表示されるものと同等です。
ページアウトされたメモリは *含みません* 。ページフォルトなしで参照可能なメモリ量を示します。

***

# Report Self

```{r}
time.lap <- c(time.lap, list(Plotting = proc.time()))

time.lap.df.tmp <- as.data.frame(
  t(
    data.frame(purrr::map(time.lap, ~ c(.["user.self"], .["sys.self"], .["elapsed"])))))
time.lap.viz <- time.lap.df.tmp %>% rownames_to_column(var = "Stage") %>% dplyr::mutate(
  user.self = user.self - lag(user.self, default = 0),
  sys.self  = sys.self - lag(sys.self, default = 0),
  elapsed   = elapsed - lag(elapsed, default = 0)) %>% dplyr::filter(Stage != "first");

formattable(time.lap.viz, list(
  user.self = color_bar("azure1"),
  sys.self = color_bar("azure2"),
  elapsed = color_bar("azure4")
))
```
